<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Provable - View Proof</title>
  <meta name="description" content="View and verify any Provable proof">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link id="ui-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/provable-sdk-ui@0.0.5/dist/browser/style.css">
  <style>
    body {
      margin: 0;
      padding: 24px;
      font-family: 'Roboto Condensed', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f6f7;
      color: #2b2d2e;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 24px;
    }

    .header h1 {
      margin: 0 0 8px;
      font-size: 1.5rem;
      color: #2b2d2e;
    }

    .header p {
      margin: 0;
      color: #6b6d6e;
      font-size: 0.9rem;
    }

    .upload-area {
      background: white;
      border: 2px dashed #d4d6d7;
      border-radius: 8px;
      padding: 48px 24px;
      text-align: center;
      transition: border-color 200ms;
    }

    .upload-area.drag-over {
      border-color: #6b7176;
      background: rgba(107, 113, 118, 0.05);
    }

    .upload-area p {
      margin: 0 0 16px;
      color: #6b6d6e;
    }

    .upload-button {
      appearance: none;
      background: #6b7176;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 10px 20px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 200ms;
    }

    .upload-button:hover {
      background: #4a4d4e;
    }

    .viewer-wrapper {
      background: white;
      border: 1px solid #d4d6d7;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .error-message {
      color: #dc2626;
      background: #fee2e2;
      border: 1px solid #fecaca;
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Provable Proof Viewer</h1>
      <p id="page-url">Loading...</p>
    </div>

    <div id="error-container"></div>

    <div id="upload-area" class="upload-area">
      <p>Drag & drop a Provable proof JSON file here or</p>
      <button id="upload-button" class="upload-button">Choose File</button>
      <input type="file" id="file-input" accept=".json,application/json" hidden>
    </div>

    <div id="viewer-wrapper" class="viewer-wrapper" hidden>
      <div id="proof-root"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/js-sha3@0.9.3/build/sha3.min.js"></script>
  <script>
    const pageUrlElement = document.getElementById('page-url');
    const uploadArea = document.getElementById('upload-area');
    const viewerWrapper = document.getElementById('viewer-wrapper');
    const proofRoot = document.getElementById('proof-root');
    const uploadButton = document.getElementById('upload-button');
    const fileInput = document.getElementById('file-input');
    const errorContainer = document.getElementById('error-container');

    let unmountViewer = null;

    const uiParams = new URLSearchParams(window.location.search);
    const uiMode = uiParams.get('ui');
    const uiVersion = uiParams.get('ui_version') || '0.0.5';
    const uiBaseOverride = uiParams.get('ui_base');
    const uiBundleBase = uiMode === 'local'
      ? (uiBaseOverride || 'http://localhost:8080').replace(/\/+$/, '')
      : `https://cdn.jsdelivr.net/npm/provable-sdk-ui@${encodeURIComponent(uiVersion)}/dist/browser`;

    function loadExternalScript(src) {
      return new Promise((resolve, reject) => {
        const existingScript = document.querySelector(`script[data-ui-bundle-src="${src}"]`);
        if (existingScript) {
          resolve();
          return;
        }

        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.dataset.uiBundleSrc = src;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error(`Failed to load UI bundle from ${src}`));
        document.head.appendChild(script);
      });
    }

    async function ensureUiBundleLoaded() {
      const stylesheet = document.getElementById('ui-stylesheet');
      if (stylesheet && stylesheet instanceof HTMLLinkElement) {
        stylesheet.href = `${uiBundleBase}/style.css`;
      }

      if (window.ProvableSdkUi && typeof window.ProvableSdkUi.mountProofViewer === 'function') {
        return true;
      }

      await loadExternalScript(`${uiBundleBase}/provable-sdk-ui.iife.js`);
      return !!(window.ProvableSdkUi && typeof window.ProvableSdkUi.mountProofViewer === 'function');
    }

    function setError(message) {
      errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
    }

    function clearError() {
      errorContainer.innerHTML = '';
    }

    function isRecord(value) {
      return typeof value === 'object' && value !== null;
    }

    function readPath(root, path) {
      let current = root;
      for (const segment of path) {
        if (!isRecord(current) || !(segment in current)) {
          return undefined;
        }
        current = current[segment];
      }
      return current;
    }

    function firstString(...values) {
      for (const value of values) {
        if (typeof value === 'string' && value.length > 0) {
          return value;
        }
      }
      return undefined;
    }

    function decodeHexString(value) {
      if (!value || typeof value !== 'string') return undefined;
      const normalized = value.startsWith('0x') ? value.slice(2) : value;
      if (normalized.length === 0 || normalized.length % 2 !== 0) return undefined;
      if (!/^[0-9a-fA-F]+$/.test(normalized)) return undefined;
      const bytes = new Uint8Array(normalized.length / 2);
      for (let i = 0; i < normalized.length; i += 2) {
        bytes[i / 2] = Number.parseInt(normalized.slice(i, i + 2), 16);
      }
      return new TextDecoder().decode(bytes);
    }

    function decodeBase64ToBytes(value) {
      if (typeof value !== 'string') return undefined;
      const normalized = value.trim();
      if (!normalized || normalized.length % 4 !== 0) return undefined;
      if (!/^[A-Za-z0-9+/]+={0,2}$/.test(normalized)) return undefined;
      try {
        const binary = atob(normalized);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i += 1) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      } catch {
        return undefined;
      }
    }

    function normalizeHashAlgorithm(value) {
      if (typeof value !== 'string') return 'sha256';
      const normalized = value.toLowerCase().replace(/_/g, '').replace(/-/g, '');
      return normalized === 'keccak256' ? 'keccak256' : 'sha256';
    }

    function toDataTypeLabel(value) {
      if (!value) return undefined;
      const decoded = decodeHexString(value) || value;
      return decoded.replace(/\u0000+$/g, '');
    }

    function uniqueStrings(values) {
      const result = [];
      const seen = new Set();
      for (const value of values) {
        if (!value || seen.has(value)) continue;
        seen.add(value);
        result.push(value);
      }
      return result;
    }

    function extractTopLevelDataJson(jsonText) {
      const marker = '"data"';
      const markerIndex = jsonText.indexOf(marker);
      if (markerIndex < 0) return undefined;
      const colon = jsonText.indexOf(':', markerIndex + marker.length);
      if (colon < 0) return undefined;
      let i = colon + 1;
      while (i < jsonText.length && /\s/.test(jsonText[i])) i += 1;
      if (i >= jsonText.length) return undefined;
      const first = jsonText[i];
      if (first === '"') {
        let escaped = false;
        let j = i + 1;
        while (j < jsonText.length) {
          const ch = jsonText[j];
          if (escaped) {
            escaped = false;
          } else if (ch === '\\') {
            escaped = true;
          } else if (ch === '"') {
            return jsonText.slice(i, j + 1);
          }
          j += 1;
        }
        return undefined;
      }
      if (first === '{' || first === '[') {
        const stack = [first];
        let inString = false;
        let escaped = false;
        let j = i + 1;
        while (j < jsonText.length) {
          const ch = jsonText[j];
          if (inString) {
            if (escaped) escaped = false;
            else if (ch === '\\') escaped = true;
            else if (ch === '"') inString = false;
            j += 1;
            continue;
          }
          if (ch === '"') {
            inString = true;
            j += 1;
            continue;
          }
          if (ch === '{' || ch === '[') stack.push(ch);
          if (ch === '}' || ch === ']') {
            stack.pop();
            if (stack.length === 0) return jsonText.slice(i, j + 1);
          }
          j += 1;
        }
      }
      let j = i;
      while (j < jsonText.length && jsonText[j] !== ',' && jsonText[j] !== '}') j += 1;
      return jsonText.slice(i, j).trim();
    }

    async function sha256Hex(bytes) {
      const hashBuffer = await crypto.subtle.digest('SHA-256', bytes);
      return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function createEnvelopeAdapter(rawEnvelope, rawDataJson) {
      const data = rawEnvelope.data;
      const kayros = rawEnvelope.kayros || {};

      function hasTimestampResponse() {
        return readPath(kayros, ['timestamp', 'response']) !== undefined;
      }

      function isV0() {
        return readPath(kayros, ['data', 'data_item_hex']) !== undefined
          || readPath(kayros, ['data', 'computed_hash_hex']) !== undefined
          || readPath(kayros, ['success']) !== undefined;
      }

      function getTimestampResponse() {
        return readPath(kayros, ['timestamp', 'response']);
      }

      function getRegisterResponse() {
        const response = getTimestampResponse();
        return readPath(response, ['response']) || response;
      }

      function getDataHash() {
        if (hasTimestampResponse()) {
          return firstString(
            readPath(kayros, ['hash']),
            readPath(getRegisterResponse(), ['data_item_hex']),
            readPath(getRegisterResponse(), ['data', 'data_item_hex']),
            readPath(getTimestampResponse(), ['data', 'data_item_hex']),
            readPath(kayros, ['data', 'data_item_hex'])
          );
        }

        return firstString(
          readPath(kayros, ['hash']),
          readPath(kayros, ['data', 'data_item_hex']),
          readPath(kayros, ['timestamp', 'response', 'data', 'data_item_hex'])
        );
      }

      function getDataType() {
        const raw = firstString(
          readPath(getRegisterResponse(), ['data_type']),
          readPath(getRegisterResponse(), ['data', 'data_type']),
          readPath(getTimestampResponse(), ['data', 'data_type']),
          readPath(kayros, ['data', 'data_type']),
          readPath(kayros, ['data_type'])
        );
        if (raw) return raw;

        const hex = firstString(
          readPath(getRegisterResponse(), ['data_type_hex']),
          readPath(getRegisterResponse(), ['data', 'data_type_hex']),
          readPath(getTimestampResponse(), ['data', 'data_type_hex']),
          readPath(kayros, ['data', 'data_type_hex']),
          readPath(kayros, ['data_type_hex'])
        );
        if (!hex) return undefined;
        return decodeHexString(hex) || hex;
      }

      function getDataTypeLabel() {
        return toDataTypeLabel(getDataType());
      }

      function getDataTypeLookupCandidates() {
        const raw = firstString(
          readPath(getRegisterResponse(), ['data_type']),
          readPath(getRegisterResponse(), ['data', 'data_type']),
          readPath(getTimestampResponse(), ['data', 'data_type']),
          readPath(kayros, ['data', 'data_type']),
          readPath(kayros, ['data_type'])
        );
        const decodedRaw = raw ? decodeHexString(raw) : undefined;
        const type = getDataType();
        const decodedType = type ? decodeHexString(type) : undefined;
        const label = getDataTypeLabel();
        return uniqueStrings([raw, decodedRaw, type, decodedType, label]);
      }

      function getKayrosHash() {
        return firstString(
          readPath(getTimestampResponse(), ['data', 'computed_hash_hex']),
          readPath(getRegisterResponse(), ['data', 'computed_hash_hex']),
          readPath(getRegisterResponse(), ['computed_hash_hex']),
          readPath(getRegisterResponse(), ['hash']),
          readPath(kayros, ['data', 'computed_hash_hex'])
        );
      }

      function getTimeUUID() {
        return firstString(
          readPath(getRegisterResponse(), ['data', 'timeuuid_hex']),
          readPath(getRegisterResponse(), ['timeuuid_hex']),
          readPath(getRegisterResponse(), ['data', 'timeuuid']),
          readPath(getRegisterResponse(), ['timeuuid']),
          readPath(getTimestampResponse(), ['data', 'timeuuid_hex']),
          readPath(getTimestampResponse(), ['data', 'timeuuid']),
          readPath(kayros, ['data', 'timeuuid_hex'])
        );
      }

      function getHashAlgorithm() {
        return normalizeHashAlgorithm(readPath(kayros, ['hashAlgorithm']));
      }

      function getUtf8Bytes(value) {
        return new TextEncoder().encode(value);
      }

      function getObjectBytes() {
        if (typeof rawDataJson === 'string') {
          return getUtf8Bytes(rawDataJson);
        }
        return getUtf8Bytes(JSON.stringify(data));
      }

      function getData() {
        if (typeof data !== 'string') {
          return getObjectBytes();
        }
        const base64Bytes = decodeBase64ToBytes(data);
        if (isV0() && base64Bytes) {
          return base64Bytes;
        }
        return getUtf8Bytes(data);
      }

      function getByteCandidates() {
        const candidates = [];
        const seen = new Set();

        function add(bytes) {
          if (!bytes) return;
          const key = bytesToHex(bytes);
          if (seen.has(key)) return;
          seen.add(key);
          candidates.push(bytes);
        }

        if (typeof data === 'string') {
          const utf8Bytes = getUtf8Bytes(data);
          const base64Bytes = decodeBase64ToBytes(data);
          if (isV0()) {
            add(base64Bytes);
            add(utf8Bytes);
          } else {
            add(utf8Bytes);
            add(base64Bytes);
          }
          return candidates;
        }

        if (typeof rawDataJson === 'string') {
          add(getUtf8Bytes(rawDataJson));
        }
        add(getUtf8Bytes(JSON.stringify(data)));
        return candidates;
      }

      async function computeDataHash() {
        const preferred = getHashAlgorithm();
        const alternate = preferred === 'keccak256' ? 'sha256' : 'keccak256';
        const expected = getDataHash() ? getDataHash().toLowerCase() : undefined;

        async function digest(bytes, algorithm) {
          if (algorithm === 'keccak256') {
            if (typeof window.keccak256 !== 'function') {
              throw new Error('keccak256 helper not available');
            }
            return window.keccak256(bytes);
          }
          return sha256Hex(bytes);
        }

        const candidates = getByteCandidates();
        if (expected) {
          for (const bytes of candidates) {
            const preferredHash = await digest(bytes, preferred);
            if (preferredHash === expected) return preferredHash;
            const alternateHash = await digest(bytes, alternate);
            if (alternateHash === expected) return alternateHash;
          }
        }

        return digest(getData(), preferred);
      }

      return {
        data,
        kayros,
        getDataHash,
        getDataType,
        getDataTypeLabel,
        getDataTypeLookupCandidates,
        getKayrosHash,
        getTimeUUID,
        getHashAlgorithm,
        isV0,
        getData,
        computeDataHash
      };
    }

    function isEnvelope(value) {
      return isRecord(value) && 'data' in value && 'kayros' in value;
    }

    function unmountExistingViewer() {
      if (typeof unmountViewer === 'function') {
        unmountViewer();
      }
      unmountViewer = null;
      proofRoot.innerHTML = '';
    }

    function getDisplayedSource(envelope) {
      if (!envelope || !isRecord(envelope.data)) {
        return 'Proof loaded';
      }
      return envelope.data.pageUrl || envelope.data.url || readPath(envelope.data, ['meta', 'url']) || 'Proof loaded';
    }

    function renderEnvelope(envelope, rawText) {
      if (!window.ProvableSdkUi || typeof window.ProvableSdkUi.mountProofViewer !== 'function') {
        setError('provable-sdk-ui browser bundle did not load.');
        return;
      }

      clearError();
      unmountExistingViewer();

      const rawDataJson = typeof rawText === 'string' ? extractTopLevelDataJson(rawText) : undefined;
      const adapter = createEnvelopeAdapter(envelope, rawDataJson);

      uploadArea.hidden = true;
      viewerWrapper.hidden = false;
      pageUrlElement.textContent = getDisplayedSource(envelope);

      unmountViewer = window.ProvableSdkUi.mountProofViewer(proofRoot, {
        envelope: adapter,
        theme: 'light',
        showRemoteRecord: true
      });
    }

    async function parseJsonText(text) {
      const parsed = JSON.parse(text);
      if (!isEnvelope(parsed)) {
        throw new Error('Invalid proof JSON. Expected an envelope with { data, kayros }.');
      }
      return { parsed, text };
    }

    async function loadFromUrl(url) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch proof URL (${response.status})`);
      }
      const text = await response.text();
      const { parsed } = await parseJsonText(text);
      renderEnvelope(parsed, text);
    }

    async function loadFromBase64(dataParam) {
      let decoded;
      try {
        decoded = decodeURIComponent(escape(atob(dataParam)));
      } catch {
        decoded = atob(dataParam);
      }
      const { parsed } = await parseJsonText(decoded);
      renderEnvelope(parsed, decoded);
    }

    function loadFromFile(file) {
      const reader = new FileReader();
      reader.onload = async (event) => {
        try {
          const text = String(event.target && event.target.result ? event.target.result : '');
          const { parsed } = await parseJsonText(text);
          renderEnvelope(parsed, text);
        } catch (error) {
          setError(error instanceof Error ? error.message : String(error));
        }
      };
      reader.onerror = () => setError('Failed to read selected file.');
      reader.readAsText(file);
    }

    async function init() {
      try {
        const bundleReady = await ensureUiBundleLoaded();
        if (!bundleReady) {
          throw new Error('provable-sdk-ui browser bundle did not load.');
        }
      } catch (error) {
        uploadArea.hidden = false;
        viewerWrapper.hidden = true;
        pageUrlElement.textContent = 'Failed to load proof viewer UI';
        setError(error instanceof Error ? error.message : String(error));
        return;
      }

      const params = new URLSearchParams(window.location.search);
      const urlParam = params.get('url');
      const dataParam = params.get('data');

      if (urlParam) {
        try {
          await loadFromUrl(urlParam);
          return;
        } catch (error) {
          uploadArea.hidden = false;
          viewerWrapper.hidden = true;
          pageUrlElement.textContent = 'Failed to load proof from URL';
          setError(error instanceof Error ? error.message : String(error));
          return;
        }
      }

      if (dataParam) {
        try {
          await loadFromBase64(dataParam);
          return;
        } catch (error) {
          uploadArea.hidden = false;
          viewerWrapper.hidden = true;
          pageUrlElement.textContent = 'Failed to load proof from data';
          setError(error instanceof Error ? error.message : String(error));
          return;
        }
      }

      uploadArea.hidden = false;
      viewerWrapper.hidden = true;
      pageUrlElement.textContent = 'Upload a proof file to view';
    }

    uploadArea.addEventListener('dragover', (event) => {
      event.preventDefault();
      uploadArea.classList.add('drag-over');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('drag-over');
    });

    uploadArea.addEventListener('drop', (event) => {
      event.preventDefault();
      uploadArea.classList.remove('drag-over');
      const file = event.dataTransfer && event.dataTransfer.files ? event.dataTransfer.files[0] : null;
      if (file) {
        loadFromFile(file);
      }
    });

    uploadButton.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0] ? fileInput.files[0] : null;
      if (file) {
        loadFromFile(file);
      }
    });

    init();
  </script>
</body>
</html>
